<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>webgl-demo69</title>
    <link rel="stylesheet" href="../../css/style.css">
    <script src="../../js/libs/minMatrixb.js"></script>
    <script src="../../node_modules/ccapture.js/build/CCapture.all.min.js"></script>
  </head>
  <style media="screen">
    #pane {
      margin: auto;
      max-width: 512px;
    }
    #canvas {
      display: block;
      margin: 10px auto;
    }
  </style>
  <body>
    <div id="pane">
      <canvas id="canvas"></canvas>
      <p><input id="playButton" type="button" value="video loading..."></p>
      <p><input id="difference" type="range" value="50" min="0" max="100"> difference (0.0 to 1.0)</p>
    </div>
    <script id="video_vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec2 texCoord;
    uniform mat4 mvpMatrix;
    varying vec2 vTexCoord;

    void main(void){
      vTexCoord = texCoord;
      gl_Position = mvpMatrix * vec4(position, 1.0);
    }
    </script>

    <script id="video_fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform sampler2D texture;
    uniform float difference;
    varying vec2 vTexCoord;
    const vec3 chromaKeyColor = vec3(0.69, 0.55, 0.65);
    // const vec3 chromaKeyColor = vec3(0.0, 1.0, 0.0);

    void main(void){
      vec4 smpColor = texture2D(texture, vTexCoord);
      float diff = length(chromaKeyColor - smpColor.rgb);
      if(diff < difference){
        discard;
      }else{
        gl_FragColor = smpColor;
      }
    }
    </script>

    <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec4 color;
    uniform mat4 mvpMatrix;
    varying vec4 vColor;

    void main(void){
      vColor = color;
      gl_Position = mvpMatrix * vec4(position, 1.0);
    }
    </script>

    <script id="fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vColor;

    void main(void){
      gl_FragColor = vColor;
    }
    </script>


    <script type="text/javascript">
    // canvas とクォータニオンをグローバルに扱う
    var canvas;
    var video;
    var q = new qtnIV();
    var qt = q.identity(q.create());

    // マウスムーブイベントに登録する処理
    function mouseMove(e){
      var cw = canvas.width;
      var ch = canvas.height;
      var wh = 1 / Math.sqrt(cw * cw + ch * ch);
      var x = e.clientX - canvas.offsetLeft - cw * 0.5;
      var y = e.clientY - canvas.offsetTop - ch * 0.5;
      var sq = Math.sqrt(x * x + y * y);
      var r = sq * 2.0 * Math.PI * wh;
      if(sq != 1){
        sq = 1 / sq;
        x *= sq;
        y *= sq;
      }
      q.rotate(r, [y, x, 0.0], qt);
    }

    // 再生可能なビデオタイプを調べる
    function checkVideoType(){
      if(video.canPlayType('video/mp4') === 'maybe'){
        return 'mp4';
      }else if(video.canPlayType('video/webm') === 'maybe'){
        return 'webm';
      }else{
        return null;
      };
    };

    window.onload = function(){
      // canvasエレメントを取得
      canvas = document.getElementById('canvas');
      canvas.width = 512;
      canvas.height = 512;
      // canvas.width = window.innerWidth;
      // canvas.height = window.innerHeight;

      // input エレメントへの参照を取得
      var button = document.getElementById('playButton');

      // input が押されたらレンダリング開始
      button.addEventListener('click', function(){
        if(button.value === 'running'){
          button.value = 'paused';
          video.pause();
          // button.disabled = false;
        }else{
          button.value = 'running';
          // button.disabled = true;
          video.play();
          render();
        }
      }, true);

      // ビデオエレメントを生成
      video = document.createElement('video');

      // ビデオタイプのチェック
      var videoExt = checkVideoType();
      if(videoExt === null){
        alert('not supported');
        return;
      }

      // ビデオエレメントにキャッシュ完了イベントを登録
      video.addEventListener('canplaythrough', function(){
        if(button.value !== 'running'){
          button.value = 'can play video';
          button.disabled = false;
        }
      }, true);

      // ビデオエレメントのリピート再生を設定
      video.addEventListener('ended', function(){
        video.play();
      }, true);

      // ソースファイルの読み込み
      video.src = 'Puella Magi Madoka Magica - Vol.01 Menu (BD 1280x720 AVC AAC).' + videoExt;
    };

    function render(){
      video.videoWidth /= 2.0;
      video.videoHeight /= 2.0;
      canvas.width = video.videoWidth / 2.0;
      canvas.height = video.videoHeight / 2.0;

      // input 要素への参照を取得
      var dRange = document.getElementById('difference');

      // イベント処理
      canvas.addEventListener('mousemove', mouseMove, true);

      // webglコンテキストを取得
      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      //頂点シェーダとフラグメントシェーダからプログラムオブジェクトを生成
      var prg = create_program(create_shader('vs'), create_shader('fs'));
      // attributeLocationを配列に取得
      var attLocation = new Array();
      attLocation[0] = gl.getAttribLocation(prg, 'position');
      attLocation[1] = gl.getAttribLocation(prg, 'color');
      // attributeの要素数を配列に格納
      var attStride = new Array();
      attStride[0] = 3;
      attStride[1] = 4;
      var uniLocation = new Array();
      uniLocation[0] = gl.getUniformLocation(prg, 'mvpMatrix');

      //正射影用のシェーダ
      var vPrg = create_program(create_shader('video_vs'), create_shader('video_fs'));
      // attributeLocationを配列に取得
      var vAttLocation = new Array();
      vAttLocation[0] = gl.getAttribLocation(vPrg, 'position');
      vAttLocation[1] = gl.getAttribLocation(vPrg, 'texCoord');
      // vAttributeの要素数を配列に格納
      var vAttStride = new Array();
      vAttStride[0] = 3;
      vAttStride[1] = 2;
      var vUniLocation = new Array();
      vUniLocation[0] = gl.getUniformLocation(vPrg, 'mvpMatrix');
      vUniLocation[1] = gl.getUniformLocation(vPrg, 'texture');
      vUniLocation[2] = gl.getUniformLocation(vPrg, 'difference');

      // キューブモデル
      var cubeData = cube(2.0);
      var cPosition = create_vbo(cubeData.p);
      var cColor = create_vbo(cubeData.c);
      var cVBOList = [cPosition, cColor];
      var cIndex = create_ibo(cubeData.i);

      // 球体モデル
      var sphereData = sphere(64, 64, 1.0);
      var sPosition = create_vbo(sphereData.p);
      var sColor = create_vbo(sphereData.c);
      var sVBOList = [sPosition, sColor];
      var sIndex = create_ibo(sphereData.i);

      // 正射影用の板ポリゴン
      var position = [
        -1.0, 1.0, 0.0,
         1.0, 1.0, 0.0,
        -1.0, -1.0, 0.0,
         1.0, -1.0, 0.0
      ];
      var texCoord = [
         0.0, 0.0,
         1.0, 0.0,
         0.0, 1.0,
         1.0, 1.0
      ];
      var index = [
        0, 2, 1,
        2, 3, 1
      ];

      var vPosition = create_vbo(position);
      var vTexCoord = create_vbo(texCoord);
      var vVBOList  = [vPosition, vTexCoord];
      var vIndex    = create_ibo(index);

      // 各種座標変換行列の初期化
      var m = new matIV();
      var mMatrix = m.identity(m.create());
      var vMatrix = m.identity(m.create());
      var pMatrix = m.identity(m.create());
      var tmpMatrix = m.identity(m.create());
      var mvpMatrix = m.identity(m.create());
      var invMatrix = m.identity(m.create());
      var ortMatrix = m.identity(m.create());

      // 正射影用の座標変換行列
      m.lookAt([0.0, 0.0, 0.5], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], vMatrix);
      m.ortho(-1.0, 1.0, 1.0, -1.0, 0.1, 1, pMatrix);
      m.multiply(pMatrix, vMatrix, ortMatrix);

      // 深度テストとカリング有効化
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.CULL_FACE);

      // カウンタの宣言
      var count = 0;

      // テクスチャ関連
      var videoTexture = gl.createTexture(gl.TEXTURE_2D);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, videoTexture);
      // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      // 恒常ループ
      (function(){
        // カウンタをインクリメントする
        count++;

        // カウンタを元にラジアンを算出
        var rad = (count % 360) * Math.PI / 180;

        // canvasを初期化
        gl.clearColor(0.0, 0.7, 0.7, 1.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // テクスチャを更新する
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

        // ビュー×プロジェクション座標変換行列
        var eyePosition = new Array();
        var camUpDirection = new Array();
        q.toVecIII([0.0, 0.0, 7.0], qt, eyePosition);
        q.toVecIII([0.0, 1.0, 0.0], qt, camUpDirection);
        m.lookAt(eyePosition, [0.0, 0.0, 0.0], camUpDirection, vMatrix);
        m.perspective(45, canvas.width / canvas.height, 0.1, 10.0, pMatrix);
        m.multiply(pMatrix, vMatrix, tmpMatrix);

        // プログラムオブジェクトの選択
        gl.useProgram(prg);

        // 球体のレンダリング
        set_attribute(sVBOList, attLocation, attStride);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sIndex);
        m.identity(mMatrix);
        m.translate(mMatrix, [2.0, 0.0, 0.0], mMatrix);
        m.rotate(mMatrix, rad, [1.0, 1.0, 0.0], mMatrix);
        m.multiply(tmpMatrix, mMatrix, mvpMatrix);
        gl.uniformMatrix4fv(uniLocation[0], false, mvpMatrix);
        gl.drawElements(gl.TRIANGLES, sphereData.i.length, gl.UNSIGNED_SHORT, 0);

        // キューブのレンダリング
        set_attribute(cVBOList, attLocation, attStride);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cIndex);
        m.identity(mMatrix);
        m.translate(mMatrix, [-2.0, 0.0, 0.0], mMatrix);
        m.rotate(mMatrix, rad, [1.0, 1.0, 0.0], mMatrix);
        m.rotate(mMatrix, Math.PI, [0.0, 0.0, 1.0], mMatrix);
        m.multiply(tmpMatrix, mMatrix, mvpMatrix);
        gl.uniformMatrix4fv(uniLocation[0], false, mvpMatrix);
        gl.drawElements(gl.TRIANGLES, cubeData.i.length, gl.UNSIGNED_SHORT, 0);

        // プログラムオブジェクトの選択
        gl.useProgram(vPrg);

        // 板ポリゴンのレンダリング
        set_attribute(vVBOList, vAttLocation, vAttStride);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vIndex);
        gl.uniformMatrix4fv(vUniLocation[0], false, ortMatrix);
        gl.uniform1i(vUniLocation[1], 0);
        gl.uniform1f(vUniLocation[2], dRange.value / 100);
        gl.drawElements(gl.TRIANGLES, index.length, gl.UNSIGNED_SHORT, 0);

        // コンテキストの再描画
        gl.flush();

        // ループのために再帰呼び出し
        // setTimeout(arguments.callee);
        requestAnimationFrame(arguments.callee);
      })();

      // create WebGLShader object
      function create_shader(id) {
        var shader;
        var scriptElement = document.getElementById(id);
        if (!scriptElement) { return };
        switch (scriptElement.type) {
          case 'x-shader/x-vertex':
            shader = gl.createShader(gl.VERTEX_SHADER);
            break;
          case 'x-shader/x-fragment':
            shader = gl.createShader(gl.FRAGMENT_SHADER);
            break;
          default:
            return;
        };

        gl.shaderSource(shader, scriptElement.text);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          return shader;
        } else {
          alert(gl.getShaderInfoLog(shader));
        }
      };

      // create WebGLProgram object
      function create_program(vs, fs){
        var program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);

        gl.linkProgram(program);

        if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
          gl.useProgram(program);
          return program;
        } else {
          alert(gl.getProgramInfoLog(program));
          console.log(gl.getProgramInfoLog(program));
        }
      };


      // create WebGLBuffer for vertex
      function create_vbo(data) {
        var vbo = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return vbo;
      };

      function set_attribute(vbo, attL, attS) {
        for (var i in vbo) {
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo[ i ]);
          gl.enableVertexAttribArray(attL[ i ]);
          gl.vertexAttribPointer(attL[ i ], attS[ i ], gl.FLOAT, false, 0, 0);
        }
      };

      // create WebGLBuffer for index
      function create_ibo(data) {
        var ibo = gl.createBuffer();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        return ibo;
      };

      // テクスチャを生成する関数
      function create_texture(source){
        // イメージオブジェクトの生成
        var img = new Image();

        // データのオンロードをトリガーにする
        img.onload = function(){
          // テクスチャオブジェクトの生成
          var tex = gl.createTexture();

          // テクスチャをバインドする
          gl.bindTexture(gl.TEXTURE_2D, tex);

          // テクスチャへイメージを適用
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

          // ミップマップを生成
          gl.generateMipmap(gl.TEXTURE_2D);

          // テクスチャのバインドを無効化
          gl.bindTexture(gl.TEXTURE_2D, null);

          // 生成したテクスチャをグローバル変数に代入
          texture = tex;
        };

        // イメージオブジェクトのソースを指定
        img.src = source;
      }

      // フレームバッファをオブジェクトとして生成する関数
      function create_framebuffer(width, height){
        var frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

        var depthRenderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);

        var fTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, fTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fTexture, 0);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        return {f: frameBuffer, d: depthRenderBuffer, t: fTexture};
      };

      function create_cube_texture(source, target) {
        var cImg = [];
        for(var i = 0; i < source.length; i ++) {
          cImg[i] = new cubeMapImage();
          cImg[i].data.src = source[i];
        };

        function cubeMapImage() {
          this.data = new Image();
          this.data.onload = function() {
            this.imageDataLoaded = true;
            checkLoaded();
          };
        };

        function checkLoaded() {
          if(cImg[0].data.imageDataLoaded &&
             cImg[1].data.imageDataLoaded &&
             cImg[2].data.imageDataLoaded &&
             cImg[3].data.imageDataLoaded &&
             cImg[4].data.imageDataLoaded &&
             cImg[5].data.imageDataLoaded){generateCubeMap();}
        };

        function generateCubeMap() {
          var tex = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, tex);
          for(var j = 0; j < source.length; j++) {
            gl.texImage2D(target[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, cImg[j].data);
          }
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          cubeTexture = tex;
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
        }
      };


    };

    </script>
  </body>
</html>
